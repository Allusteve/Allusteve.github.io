<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Control Rig是一个基于节点的绑定系统，其本质是一个骨骼约束脚本。通过在根骨骼空间中建立一系列的点或者说Element，将其绑定在想要驱动的骨骼上，从而实现对骨骼的控制和约束。它的Rigging是建立在骨骼上的，其操纵的最小颗粒就是骨骼。所以Control Rig对于一个没有骨骼或者顶点没有绑定到骨骼上的Mesh是没有意义的。 Control Rig的启用和创建Control Rig以引">
<meta property="og:type" content="article">
<meta property="og:title" content="Control Rig分析总结">
<meta property="og:url" content="http://example.com/2021/12/19/Control-Rig%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="夏日梦蓝">
<meta property="og:description" content="Control Rig是一个基于节点的绑定系统，其本质是一个骨骼约束脚本。通过在根骨骼空间中建立一系列的点或者说Element，将其绑定在想要驱动的骨骼上，从而实现对骨骼的控制和约束。它的Rigging是建立在骨骼上的，其操纵的最小颗粒就是骨骼。所以Control Rig对于一个没有骨骼或者顶点没有绑定到骨骼上的Mesh是没有意义的。 Control Rig的启用和创建Control Rig以引">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-12-19T09:08:54.000Z">
<meta property="article:modified_time" content="2021-12-19T09:10:51.974Z">
<meta property="article:author" content="ALiang">
<meta property="article:tag" content="UE4">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2021/12/19/Control-Rig%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Control Rig分析总结 | 夏日梦蓝</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">夏日梦蓝</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">随便写写</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/19/Control-Rig%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ALiang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="夏日梦蓝">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Control Rig分析总结
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-12-19 17:08:54 / 修改时间：17:10:51" itemprop="dateCreated datePublished" datetime="2021-12-19T17:08:54+08:00">2021-12-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Animation/" itemprop="url" rel="index"><span itemprop="name">Animation</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p> Control Rig是一个基于节点的绑定系统，其本质是一个骨骼约束脚本。通过在根骨骼空间中建立一系列的点或者说Element，将其绑定在想要驱动的骨骼上，从而实现对骨骼的控制和约束。它的Rigging是建立在骨骼上的，其操纵的最小颗粒就是骨骼。所以Control Rig对于一个没有骨骼或者顶点没有绑定到骨骼上的Mesh是没有意义的。</p>
<h1 id="Control-Rig的启用和创建"><a href="#Control-Rig的启用和创建" class="headerlink" title="Control Rig的启用和创建"></a>Control Rig的启用和创建</h1><p>Control Rig以引擎插件的形式集成在引擎中，当前版本默认是关闭的，需要手动去开启</p>
<p>可以用两种方法为骨骼网格体创建Control Rig。第一种方法，右键点击一个骨骼网格体资产，选择 创建Control Rig（Create Control Rig）。这会新建一个 Control Rig 资产并自动将你的骨骼网格体指定为绑定对象。此资产会自动沿用骨骼网格体的名称，并且以 _CtrlRig 作为名称后缀。</p>
<p>第二种方法是手动创建一个 Control Rig。步骤是在内容浏览器中点击右键，选择 动画（Animation）&gt; Control Rig。在上下文菜单中，选择 ControlRig 并点击 创建（Create）。</p>
<p>创建一个空白的Control Rig资源后，可以在Rig Hierarchy面板中手动import mesh。从这里就可以看到Control Rig不同于以往ue4动画资源的地方，它是可以独立创建资源。而且USkeletalMesh在这里是一个Preview Mesh的概念。</p>
<p>从引用关系图可以看到，Control Rig并没有强引用USkeletalMesh和USkeleton。这就可以看到Control Rig可以在不同骨骼角色之间共用的可能性。 后面会尝试解释Control Rig是如何能在不同的骨骼之间工作的。</p>
<h1 id="Rig-Hierarchy"><a href="#Rig-Hierarchy" class="headerlink" title="Rig Hierarchy"></a>Rig Hierarchy</h1><p>Rig层级（Rig Hierarchy）面板类似于大纲视图，可以查看当前骨架和控制点的层级。这也是你新建 骨骼（Bones）、控制点（Controls） 和 空间（Spaces） 的主要区域。要创建这些元素，在面板中点击右键，这是Control Rig中最重要的数据面板。这3种元素都是继承于FRigElement，拥有一个基本的name和index。</p>
<h2 id="Bone"><a href="#Bone" class="headerlink" title="Bone"></a>Bone</h2><p>Bone分为Imported和User两种类型。ImportedBone在Rig Hierarchy中用白色标记，它在从SkeletalMesh创建Control Rig或者手动调用import mesh时生成， 而UserBone是用户在Hierarchy面板中手动创建，用绿色标记。这里的Bone可以看作是一个带有父子关系的transform变量，和传统动画资源Skeleton Tree里的bone不是一个概念。而且不能挂靠在Control和Space下。UserBone在ue4.26中推出，目前还没有看到其相关应用。在代码中，两者的数据类型是完全相同的，都是FRigBone，只有成员变量Type是不同的，所以其实这两者在使用中并没有任何区别。</p>
<h2 id="Space"><a href="#Space" class="headerlink" title="Space"></a>Space</h2><p>在Rig Hierarchy中用红色标记。Bone和Space在视口中都没有可视化标记，也不能在视口中移动。Space可以挂靠在Bone，Control，Space下。它的作用类似于maya软件中的group，或者蓝图BP里的SceneComponent。 从代码中可以看到，Control的local transform都是相对于Space的看，当Control挂在Space下，该Space可视作Control的原点，它用来组织并偏移挂载其下的一系列Controls。</p>
<h2 id="Control"><a href="#Control" class="headerlink" title="Control"></a>Control</h2><p>在Rig Hierarchy中用蓝色小球标记。是在Control Rig中使用最多的Element。它拥有被称作Gizmo的可视化形状工具，可以操纵这些Gizmo来改变Control的参数。Control可以用多种不同的数据类型表示，越复杂的数据其可控制能力就越强。其最常见的用法就是将Control和某一个Target Bone绑定在一起，用Control的Tranform数据去驱动实际Bone的Transform。</p>
<p>选择合适的可视化Gizmo，可以使得Control的功能更加清晰易懂。例如只想使用Control来控制骨骼的旋转，那么用一个圆环套在身上就非常合适。下面两个Control Rig模板就很好体现了这个思想。</p>
<p>在Control Rig编辑器的Class Settings可以修改Gizmo Library类，如果有需求可以编写自己的GizmoLibrary来扩展更多的几何可视化工具。</p>
<h2 id="Control-Rig-功能共享的思考"><a href="#Control-Rig-功能共享的思考" class="headerlink" title="Control Rig 功能共享的思考"></a>Control Rig 功能共享的思考</h2><p>为什么说Control Rig可以在不同骨骼之间共享？因为Control Rig在其内部数据结构中并没有维护或者序列化任何USkeleton或者FRerenceSkeleton对象。而是声明了FRigHierarchyContainer结构体，这个结构体主要由FRigBoneHierarchy，FRigSpaceHierarchy，FRigControlHierarchy，FRigCurveContainer这4个struct构成，这4个struct可以视作对应数据结构（bone, space, control ,curve）的数组。</p>
<p>对这些数据结构进行赋值，计算等一系列操作，对于Control Rig来说都是其内部行为，与外界资源都是独立的。那么引擎的动画模块是如何使用它并与真正的SkeletalMesh建立映射关系呢？关键就是通过骨骼bone的名称FName来完成。当在Sequencer或者动画蓝图里使用Control Rig时，底层的逻辑都是在FAnimNode_ControlRig动画节点来完成。</p>
<p>既然是动画蓝图，那么一定会强引用一个ReferenceSkeleton。在该动画节点的CacheBones接口上，会获取动画蓝图引用的骨骼的所有名称并存进哈希表ControlRigBoneMapping。在动画节点的Evaluate接口，首先会调用UpdateInput，把ControlRig动画节点之前计算好的骨骼FPoseContext传进ControlRig内部，然后调用ControlRig的Evaluate_AnyThread接口，进行ControlRig内部本地的骨骼控制约束计算，最后调用UpdateOuput，这里会把ControlRig内部更新的数据结构与实际动画蓝图对应的骨骼数据进行同步，将结果写进FPoseContext。</p>
<p> 可以看到整体逻辑十分简单，这里的ControlRig就像一个封装好的函数，对于动画蓝图来说就像一个黑箱。</p>
<p> UpdateInput和UpdateOutput除了空间上的转换，流程上都是一样的。根据之前缓存好的哈希表，通过骨骼FName来索引。只要Control Rig的BoneHierarchy中的bone名称和外部Skeleton的bone名称相同，那么就能成功将数据传入和传出于Control Rig。</p>
<p>之前提到过Imported bone和User bone的关系。从这里的流程可以看到，两者都作为FRigBoneHierarchy的数据成员在与外部模块进行数据传输时没有任何区别。事实上只要FName匹配，外部的bone数据就能传进Control Rig，内部计算好的数据也能传输出去。</p>
<p>我在这里创建了一个空的Control Rig后并没有import任何mesh的骨骼。而是自己简单创建了一个UserBone head，修改了其rotation，功能就和动画蓝图的modify bone一样。然后在动画蓝图链接上可以看到效果是完全一致的。</p>
<p>还有一点要注意的是，无论是bone, space还是control。它们都有两套transform或者data。拿骨骼来说，bone有InitialTransform和CurrentTransform，两者区别是，InitialTransform是会被序列化, CurrentTraansform则是运行时的临时数据。因为ControlRig是一个独立资源，所以它的所有Rig数据都是可以被更改的。当我们使用Sequencer或者动画蓝图ControlRig节点时，当勾选节点的SetRefPoseFromSkeleton功能时，节点会在初始化时用AnimInstance引用的FRerenceSkeleton来初始化RigBone的initial数据。使得Control Rig可以自动适应不同骨骼（高矮胖瘦）</p>
<p>但是Space和Control就需要我们手动去设置了，这也是Setup event的主要功能。</p>
<h1 id="Rig-Graph"><a href="#Rig-Graph" class="headerlink" title="Rig Graph"></a>Rig Graph</h1><p>Rig图表是编写Control Rig行为脚本的主要位置。类似于蓝图编辑器EventGraph和动画蓝图编辑器AnimGraph的结合。既然是编写脚本，那么就需要脚本执行入口。在ue4.26，目前提供了3种不同的脚本逻辑入口，下面会一一介绍。首先要说明的是，Rig Graph中所有的节点都是FRigUnit，这3种脚本入口同样也是RigUnit。分别是</p>
<ul>
<li>Setup event        -  FRigUnit_PrepareForExecution</li>
<li>Forwards Solve   -  FRigUnit_BeginExecution</li>
<li>Backwards Solve -  FRigUnit_InverseExecution</li>
</ul>
<p>这3个Unit的结构除了static变量EventName，其它几乎一模一样。所以这3者的区别就是被引擎调用的时机。</p>
<h2 id="Setup-Event"><a href="#Setup-Event" class="headerlink" title="Setup Event"></a>Setup Event</h2><p>可以用来初始化Control的Transform包括平移，旋转，缩放。该功能在4.26新出现，前面说过Control Rig在不同USkeleton上运行时，会有适配问题。Bone在初始化时候会自动适配，而Control就需要自己来调整了。那么SetupEvent就出现了，除了特殊的编辑器预览模式下，该event在整个生命周期只会运行一次，可以理解为Actor的BeginPlay事件。</p>
<h2 id="Forwards-Solve"><a href="#Forwards-Solve" class="headerlink" title="Forwards Solve"></a>Forwards Solve</h2><p>是Control Rig最常用的逻辑入口，在4.26之前的Control Rig只有这一个逻辑入口。在UControlRig的构造函数中会默认向EventQueue添加BeginExecution，然后Control Rig在每一帧的Evalutae_AnyThread都会去执行Forwards Solve对应的逻辑。可以类比为Actor的Tick事件。这是任何Control Rig脚本都应该去编写的逻辑</p>
<h2 id="Backwards-Solve"><a href="#Backwards-Solve" class="headerlink" title="Backwards Solve"></a>Backwards Solve</h2><p>这是4.26添加的新功能。其主要对应的功能就是Sequencer的BakeToControlRig功能，其功能是将一段选中的骨骼动画序列执行InverseExecution逻辑，一般为了获取Rig Graph中的Control数据，会对选中的AnimSequence的每一帧都去执行Backwards solve，从而得到每一帧中bone对应的Control Transform。</p>
<p> 该事件在目前4.26版本中只能在编辑器模式中制作Sequencer时去手动调用它。而且一定要在Control Rig里面定义了Backwards Solve，才能在该下拉列表里搜索到对应资源。暂时还没有找到其他调用入口。 </p>
<p> 从代码中可以看到，这里会遍历动画数据的每一帧，并执行InverseExecution来获取这一frame下的Control Transform。在官方给出的Control Rig demo示例中主要是针对Sequencer制作动画的，所以BackwardsSolver写得很多。但如果只是想将Control Rig用在Runtime的游戏流程中，那么是完全不需要去管Backwards Solver的。</p>
<h1 id="Sequencer使用"><a href="#Sequencer使用" class="headerlink" title="Sequencer使用"></a>Sequencer使用</h1><p> Control Rig最直接的运用就是在Sequencer，也是Epic在最近几个引擎版本更新中大力更新发展的。当把一个ControlRig资源直接拖到场景，会自动创建一个levelSequence。在Sequencer中通过Control Rig的Control Gizmo工具可以细致地控制每一个Character骨骼的每一个关节，然后添加关键帧。</p>
<p> 直接在UE4的场景里制作动画，可以让很方便地让角色和关卡场景中的物体互动，以前可能需要将椅子或者场景模型倒进maya这样的DCC软件，重新制作动画后再导出。现在只要制作的Control Rig足够精细，可以轻松操控模型的各个关节，那么就有可能制作出影视级别的动画效果，具体可以去看虚幻官方商城里的Meerkat演示demo，里面的动画都是由Control Rig和Sequencer一起完成的。也可以直接做出一段精细的动画然后将其保存为AnimSequence。</p>
<p> 这里将一段现有的动画通过Sequencer，bake成ControlRig数据，然后调整头部Control的Rotation曲线，修改了动画最后将其保存成AnimSequence。</p>
<h1 id="动画蓝图-和-Control-Rig"><a href="#动画蓝图-和-Control-Rig" class="headerlink" title="动画蓝图 和 Control Rig"></a>动画蓝图 和 Control Rig</h1><p> ControlRig在GamePlay的运用，就是利用在动画蓝图的骨骼后处理阶段用动画节点的方式将其链接进来。然后Control Rig里面是对骨骼做约束和变换。最经典的例子就是脚部ik，做Ik一般都需要解算器的location，有两种方式可以获取。第一种是在Control Rig里面声明变量，将其公开就可以通过Anim Graph来传值，所以数据的传递流程就是从角色actor到动画蓝图最后再到Control Rig；第二种方式是直接在Rig Graph里面做碰撞检测，这是4.26新添加的功能。相比来说更加方便，省去数据在不同BP传输导致的性能消耗。</p>
<p> 可以看到目前Control Rig内部支持的Trace比较简单，返回的信息比较少，如果需求复杂可能还是要使用第一种方法。对比以往在动画蓝图的AnimGraph中进行骨骼后处理，使用Control Rig本质上并没有太多区别。本质上都是对骨骼做变换，区别是动画蓝图是直接操作FRerenceSkeleton的骨骼数据，而ControlRig是从外部接受数据，内部计算，再映射回外部。</p>
<p> 两者最终达成的效果都是一致的，更多的是工作流上的不同。ControlRig会更加独立，具有低耦合的特性。</p>
<p> 这是UE4 Paragon项目中一个角色的AnimGraph结构。可以看到一个大型商业游戏角色的AnimGraph非常复杂，从各种locomotion状态的转变，动画数据的提取混合，动画偏移，分层动画再到后处理。AnimGraph几乎大包大揽地完成了动画计算的整个pipeline，而Control Rig主要的工作就是替代流程中的Post-Processing部分，一般来说动画的后处理模块也是相对比较独立的，将其转移到Control Rig使得它能够在不同骨骼角色之间也能共用（FF7 Remake就是采用了这种思路）。</p>
<p>另外在官方的文档中提到Control Rig是采用了一个轻量级的VM虚拟机，执行速度会比传统蓝图节点更快一些。</p>
<p>上面是Epic日本官方给出的数据，实际的运行效率还有待测试。</p>
<h1 id="ControlRigComponent"><a href="#ControlRigComponent" class="headerlink" title="ControlRigComponent"></a>ControlRigComponent</h1><h1 id="动画蓝图节点映射"><a href="#动画蓝图节点映射" class="headerlink" title="动画蓝图节点映射"></a>动画蓝图节点映射</h1><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p> 综合来看Control Rig，是在ue4动画系统之上的一个增强工具，而不是一个独立的系统或者替代品，它的一切行为最终都会传递到动画蓝图或者说UAnimInstance里面，再由UAnimInstance那一套延续已久的更新逻辑完成向渲染线程数据的传输，最终得到一帧新的画面。我们在ControlRig里建立一套独立的层级数据结构（bone, space, control），然后通过动画蓝图将骨骼数据映射进来，内部执行解算逻辑，再将更新后的骨骼数据映射回动画蓝图。</p>
<p>利用ControlRig可以改善Sequencer过程动画的表现，也可以在引擎内部对现有的动画资源进行修改。虽然Control Rig拥有制作动画的能力，但最好还是在DCC软件制作，Control Rig去辅助修改。对于角色的后处理动画或者程序化动画，Control Rig能做的，动画蓝图也都能做，使用Control Rig是一个工作流的改变，将一部分逻辑从动画蓝图中解耦合。同时Control Rig也拥有在不同骨骼之间共享的能力。</p>
<p>Control Rig在4.26版本已经比较完善，UE5 EA版本的Control Rig在底层和现版本几乎是一样的，只是多了一些生产上的工具和解算节点，在UE后续版本以及UE5，Control Rig应该都会是动画系统重要的更新发展方向，例如动画节点的映射功能应该很快就有了。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/UE4/" rel="tag"># UE4</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/12/05/test-my-site/" rel="prev" title="博客的第一篇文章">
      <i class="fa fa-chevron-left"></i> 博客的第一篇文章
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Control-Rig%E7%9A%84%E5%90%AF%E7%94%A8%E5%92%8C%E5%88%9B%E5%BB%BA"><span class="nav-number">1.</span> <span class="nav-text">Control Rig的启用和创建</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Rig-Hierarchy"><span class="nav-number">2.</span> <span class="nav-text">Rig Hierarchy</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Bone"><span class="nav-number">2.1.</span> <span class="nav-text">Bone</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Space"><span class="nav-number">2.2.</span> <span class="nav-text">Space</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Control"><span class="nav-number">2.3.</span> <span class="nav-text">Control</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Control-Rig-%E5%8A%9F%E8%83%BD%E5%85%B1%E4%BA%AB%E7%9A%84%E6%80%9D%E8%80%83"><span class="nav-number">2.4.</span> <span class="nav-text">Control Rig 功能共享的思考</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Rig-Graph"><span class="nav-number">3.</span> <span class="nav-text">Rig Graph</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Setup-Event"><span class="nav-number">3.1.</span> <span class="nav-text">Setup Event</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Forwards-Solve"><span class="nav-number">3.2.</span> <span class="nav-text">Forwards Solve</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Backwards-Solve"><span class="nav-number">3.3.</span> <span class="nav-text">Backwards Solve</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Sequencer%E4%BD%BF%E7%94%A8"><span class="nav-number">4.</span> <span class="nav-text">Sequencer使用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A8%E7%94%BB%E8%93%9D%E5%9B%BE-%E5%92%8C-Control-Rig"><span class="nav-number">5.</span> <span class="nav-text">动画蓝图 和 Control Rig</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ControlRigComponent"><span class="nav-number">6.</span> <span class="nav-text">ControlRigComponent</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A8%E7%94%BB%E8%93%9D%E5%9B%BE%E8%8A%82%E7%82%B9%E6%98%A0%E5%B0%84"><span class="nav-number">7.</span> <span class="nav-text">动画蓝图节点映射</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">8.</span> <span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ALiang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ALiang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
